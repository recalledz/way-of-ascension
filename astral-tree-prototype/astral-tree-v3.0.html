<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Astral Tree Editor ‚Äî v3 (positions-safe import/export, undo/redo, rotate, presets)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f172a; --ink:#e5e7eb; --muted:#94a3b8; --brand:#22d3ee; --accent:#7dd3fc;
    --grid:#23304a; --grid-strong:#2f3e63; --danger:#ef4444;
  }
  html,body{height:100%}
  body{
    margin:0; color:var(--ink);
    font:14px/1.25 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;
    display:grid; grid-template-rows:auto 1fr; background:var(--bg);
  }
  header{position:relative; z-index:2; display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:10px;
    background:linear-gradient(180deg,var(--panel),transparent); border-bottom:1px solid #16213a}
  .group{display:flex; gap:8px; align-items:center; background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:10px}
  label{color:var(--muted)}
  small{color:var(--muted)}
  input,select,button{background:#0b1220; color:var(--ink); border:1px solid #2a385a; border-radius:8px; padding:6px 8px}
  button{cursor:pointer}
  button.primary{background:linear-gradient(180deg,#1d283a,#13203a); border-color:#2a4b73}
  button.danger{background:linear-gradient(180deg,#3a1d1d,#2a1313); border-color:#733a3a}
  #wrap{position:relative; isolation:isolate}
  #network{position:absolute; inset:0}
  #gridCanvas{position:absolute; inset:0; z-index:0; pointer-events:none}
  #sidebar{
    position:absolute; top:12px; right:12px; width:360px; max-width:calc(100% - 24px);
    background:rgba(10,17,31,0.9); border:1px solid #26314d; border-radius:12px; backdrop-filter: blur(6px); z-index:3
  }
  #sidebar header{background:none; padding:10px; gap:6px; display:flex; align-items:center; justify-content:space-between}
  #sidebar section{padding:10px; border-top:1px solid #1f2a44}
  .row{display:flex; gap:8px; align-items:center; margin-bottom:8px}
  .row > *{flex:1}
  .row .shrink{flex:0 0 auto}
  .hint{color:#a5b4fc}
  #status{margin-left:auto; color:#9ca3af; font-size:12px}
  #selCount{font-weight:600}
</style>
</head>
<body>
  <header>
    <div class="group">
      <button id="btnAddNode">Add Node</button>
      <button id="btnAddEdge">Edge Mode</button>
      <button id="btnCopy">Copy</button>
      <button id="btnPaste">Paste</button>
      <button id="btnCloneRotate">Clone+Rotate</button>
      <label>¬∞ <input id="angle" type="number" value="20" style="width:72px"></label>
      <button id="btnRotate">Rotate Sel</button>
      <button id="btnUndo">Undo ‚åò/Ctrl+Z</button>
      <button id="btnRedo">Redo ‚áß+‚åò/Ctrl+Z</button>
      <button id="btnDelete" title="Delete (Del)">üóë Delete</button>
    </div>

    <div class="group">
      <label class="shrink">Edge Style</label>
      <select id="edgeStyle">
        <option value="straight">Straight</option>
        <option value="curvedCW">Curved CW</option>
        <option value="curvedCCW">Curved CCW</option>
        <option value="dynamic">Dynamic</option>
      </select>
      <label class="shrink"><input type="checkbox" id="edgeApplySel" checked> apply to selection</label>
      <label class="shrink"><input type="checkbox" id="chkRecurve" checked> recurve after rotate</label>
      <button id="btnApplyEdgeStyle">Apply</button>
    </div>

    <div class="group">
      <label class="shrink"><input type="checkbox" id="gridToggle"> grid</label>
      <label class="shrink"><input type="checkbox" id="snapToggle"> snap</label>
      <label class="shrink">size <input id="gridSize" type="number" value="30" min="6" max="200" style="width:72px"></label>
      <button id="btnFit">Fit</button>
      <span id="status">Loading‚Ä¶</span>
    </div>
  </header>

  <div id="wrap">
    <canvas id="gridCanvas"></canvas>
    <div id="network"></div>

    <aside id="sidebar">
      <header>
        <strong>Inspector</strong>
        <div><small>Selected: <span id="selCount">0</span></small></div>
      </header>

      <section>
        <div class="row">
          <label class="shrink">Label</label>
          <input id="nodeLabel" placeholder="Label (e.g., B, Notable)">
        </div>
        <div class="row">
          <label class="shrink">X</label><input id="nodeX" type="number" step="1">
          <label class="shrink">Y</label><input id="nodeY" type="number" step="1">
        </div>
        <div class="row">
          <label class="shrink">Group</label>
          <select id="nodeGroup">
            <option>Hub</option><option>Wood</option><option>Fire</option><option>Earth</option><option>Metal</option><option>Water</option>
          </select>
        </div>
        <div class="row">
          <label class="shrink">Type</label>
          <select id="nodeType"><option>basic</option><option>notable</option></select>
          <label class="shrink">Shape</label>
          <select id="nodeShape">
            <option value="dot">dot</option><option value="diamond">diamond</option><option value="triangle">triangle</option><option value="star">star</option>
          </select>
        </div>
        <div class="row">
          <label class="shrink">Color</label><input id="nodeColor" type="color" value="#7dd3fc" />
          <label class="shrink">Size</label><input id="nodeSize" type="number" value="14" min="6" max="50" />
        </div>
        <div class="row">
          <button id="btnApplyToSel" class="primary">Apply to selection</button>
        </div>
      </section>

      <section>
        <header style="padding:0 0 8px 0"><strong>Node Style Presets</strong></header>
        <small>Save color/type/shape/size. ‚ÄúUse for Add‚Äù = style of new nodes.</small>
        <div class="row">
          <input id="presetName" placeholder="Preset name" />
          <button id="btnSavePreset">Save</button>
        </div>
        <div class="row">
          <select id="presetList"></select>
          <button id="btnApplyPreset">Apply</button>
          <button id="btnUseForAdd">Use for Add</button>
        </div>
      </section>

      <section>
        <header style="padding:0 0 8px 0"><strong>Effect Presets (labels)</strong></header>
        <div class="row">
          <input id="effName" placeholder="Name"><input id="effText" placeholder="Effect text">
          <button id="btnSaveEff">Save</button>
        </div>
        <div class="row">
          <select id="selEffs"></select>
          <button id="btnApplyEff">Apply to selection</button>
          <button id="btnUseEff">Use for Add</button>
        </div>
      </section>

      <section>
        <header style="padding:0 0 8px 0"><strong>Structure Presets</strong></header>
        <small>Save selected subgraph (relative coords). Place clones later.</small>
        <div class="row">
          <input id="structName" placeholder="Structure name"><button id="btnSaveStruct">Save</button>
        </div>
        <div class="row">
          <select id="structList"></select>
          <button id="btnPlaceStruct">Place</button>
          <button id="btnDeleteStruct" class="danger">Delete</button>
        </div>
      </section>

      <section>
        <header style="padding:0 0 8px 0"><strong>Polar Snap</strong></header>
        <div class="row">
          <label class="shrink"><input type="checkbox" id="polarToggle"> apply to selection</label>
        </div>
        <div class="row">
          <label class="shrink">r</label><input id="polarR" type="number" value="100" step="1">
          <label class="shrink">Œ∏¬∞</label><input id="polarTheta" type="number" value="6" step="1">
          <button id="btnPolar">Snap</button>
        </div>
      </section>

      <section>
        <header style="padding:0 0 8px 0"><strong>Import / Export</strong></header>
        <div class="row">
          <button id="btnExport" class="primary">Export JSON</button>
          <button id="btnImport">Import JSON</button>
        </div>
        <small class="hint">Importer keeps node positions, coerces types, and drops edges pointing to missing nodes. You‚Äôll see a notice if anything was skipped.</small>
      </section>
    </aside>
  </div>

<script>
(function loadVis(){
  const status = document.getElementById('status');
  const urls = [
    'https://cdn.jsdelivr.net/npm/vis-network@9.1.6/dist/vis-network.min.js',
    'https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.6/vis-network.min.js'
  ];
  let i = 0;
  (function next(){
    if(i >= urls.length){ status.textContent = 'Failed to load vis-network'; return; }
    const s = document.createElement('script');
    s.src = urls[i++]; s.async = true;
    s.onload = init;
    s.onerror = next;
    document.head.appendChild(s);
  })();
})();

function init(){
  const status = document.getElementById('status');
  status.textContent = 'Ready ‚úì vis-network';

  const nodes = new vis.DataSet([]);
  const edges = new vis.DataSet([]);

  // ======= Undo/Redo =======
  const history = []; let redoStack = [];
  function snapshot(){ return JSON.stringify({ nodes:nodes.get(), edges:edges.get() }); }
  function pushHistory(){ history.push(snapshot()); if(history.length>300) history.shift(); redoStack = []; }
  function undo(){
    if(history.length < 2) return;
    const cur = history.pop(); redoStack.push(cur);
    const prev = JSON.parse(history[history.length-1]);
    nodes.clear(); edges.clear(); nodes.add(prev.nodes); edges.add(prev.edges);
    updateSelCount();
  }
  function redo(){
    if(!redoStack.length) return;
    const next = redoStack.pop(); history.push(next);
    const state = JSON.parse(next);
    nodes.clear(); edges.clear(); nodes.add(state.nodes); edges.add(state.edges);
    updateSelCount();
  }

  // ======= Grid & Snap =======
  const grid = { on:false, size:30 };
  const gridToggle = document.getElementById('gridToggle');
  const snapToggle = document.getElementById('snapToggle');
  const gridSizeInput = document.getElementById('gridSize');
  const gridCanvas = document.getElementById('gridCanvas');
  const ctx = gridCanvas.getContext('2d');

  function drawGrid(){
    const { width, height } = gridCanvas.getBoundingClientRect();
    gridCanvas.width = Math.max(1, Math.floor(width * devicePixelRatio));
    gridCanvas.height = Math.max(1, Math.floor(height * devicePixelRatio));
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    ctx.clearRect(0,0,gridCanvas.width, gridCanvas.height);
    if(!grid.on) return;
    const s = grid.size;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
    ctx.lineWidth = 1;
    for(let x=0; x<width; x+=s){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,height); ctx.stroke(); }
    for(let y=0; y<height; y+=s){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(width,y+0.5); ctx.stroke(); }
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-strong');
    ctx.lineWidth = 1.2;
    for(let x=0; x<width; x+=s*5){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,height); ctx.stroke(); }
    for(let y=0; y<height; y+=s*5){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(width,y+0.5); ctx.stroke(); }
  }

  gridToggle.addEventListener('change', ()=>{ grid.on = gridToggle.checked; drawGrid(); });
  gridSizeInput.addEventListener('change', ()=>{ grid.size = Math.max(4, Number(gridSizeInput.value)||30); drawGrid(); });

  // ======= Network =======
  const container = document.getElementById('network');
  const network = new vis.Network(container, { nodes, edges }, {
    physics: { enabled:false },
    interaction: { multiselect:true, hover:true, keyboard:true },
    manipulation: { enabled:false },
    layout: { improvedLayout:false },
    edges: { color:'#8ab4f8', smooth:false }, /* ‚Üê removed arrows:false */
    nodes: { shape:'dot', size:14, color:'#7dd3fc', font:{ color:'#cbd5e1' } }
  });

  // Resize grid with container
  const resizeObserver = new ResizeObserver(()=> drawGrid());
  resizeObserver.observe(document.getElementById('wrap'));

  // ======= Helpers =======
  function nextId(){ const ids = nodes.getIds(); return ids.length ? Math.max(...ids)+1 : 1; }
  function getSelection(){ return { n: network.getSelectedNodes(), e: network.getSelectedEdges() }; }
  function updateSelCount(){
    document.getElementById('selCount').textContent =
      `${network.getSelectedNodes().length} nodes, ${network.getSelectedEdges().length} edges`;
  }

  // Delete selection
  function deleteSelection(){
    const sel = getSelection();
    if(sel.e?.length) edges.remove(sel.e);
    if(sel.n?.length) nodes.remove(sel.n);
    pushHistory();
    network.unselectAll();
    updateSelCount();
  }
  document.getElementById('btnDelete').onclick = deleteSelection;
  document.addEventListener('keydown', (e)=>{
    const tag = e.target.tagName;
    const typing = tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable;
    if(!typing && (e.key === 'Delete' || e.key === 'Backspace')){ e.preventDefault(); deleteSelection(); }
  });

  network.on('selectNode', ()=> fillInspectorFromSelection());
  network.on('selectEdge', ()=> updateSelCount());
  network.on('deselectNode', ()=> fillInspectorFromSelection());
  network.on('dragEnd', params=>{
    if(snapToggle.checked && params.nodes && params.nodes.length){
      const s = grid.size;
      const upd = params.nodes.map(id=>{
        const n = nodes.get(id);
        return { id, x: Math.round(n.x/s)*s, y: Math.round(n.y/s)*s };
      });
      nodes.update(upd);
      pushHistory();
    }
  });

  // ======= Add Node =======
  const defaultPreset = { group:'Hub', type:'basic', shape:'dot', color:'#7dd3fc', size:14 };
  let currentPreset = JSON.parse(localStorage.getItem('astral_preset_current') || JSON.stringify(defaultPreset));
  let currentEffect = localStorage.getItem('astral_effect_current') || '';
  document.getElementById('btnAddNode').onclick = ()=>{
    const id = nextId();
    const label = currentEffect || (currentPreset.type==='notable' ? 'Notable' : 'B');
    nodes.add({
      id, label,
      group: currentPreset.group, type: currentPreset.type,
      shape: currentPreset.shape, color: currentPreset.color, size: currentPreset.size,
      x: 0, y: 0, fixed:false
    });
    pushHistory();
  };

  // ======= Edge mode =======
  let edgeMode=false, edgeFrom=null;
  const btnEdge = document.getElementById('btnAddEdge');
  btnEdge.onclick = ()=>{
    edgeMode = !edgeMode;
    btnEdge.textContent = edgeMode ? 'Edge Mode (ON)' : 'Edge Mode';
    edgeFrom = null;
  };
  network.on('click', p=>{
    if(!edgeMode) return;
    const nodeId = p.nodes[0]; if(!nodeId) return;
    if(edgeFrom == null){ edgeFrom = nodeId; }
    else { edges.add({ from:edgeFrom, to:nodeId }); edgeFrom = null; pushHistory(); }
  });

  // ======= Rotate selection =======
  function rotateSelection(deg){
    const sel = network.getSelectedNodes(); if(!sel.length) return;
    const pts = sel.map(id => nodes.get(id));
    const cx = pts.reduce((s,n)=>s+n.x,0)/pts.length, cy = pts.reduce((s,n)=>s+n.y,0)/pts.length;
    const a = deg*Math.PI/180, cos=Math.cos(a), sin=Math.sin(a);
    const upd = pts.map(n => ({ id:n.id, x: cx + (n.x-cx)*cos - (n.y-cy)*sin, y: cy + (n.x-cx)*sin + (n.y-cy)*cos }));
    nodes.update(upd);
    if(document.getElementById('chkRecurve').checked){ recurveEdgesWithinSelection(sel, cx, cy); }
    pushHistory();
  }
  function recurveEdgesWithinSelection(selIds, cx, cy){
    const selSet = new Set(selIds); const upd=[];
    edges.forEach(e=>{
      if(!(selSet.has(e.from) && selSet.has(e.to))) return;
      const f = nodes.get(e.from), t = nodes.get(e.to);
      const mx=(f.x+t.x)/2, my=(f.y+t.y)/2; const tx=t.x-f.x, ty=t.y-f.y;
      const zx = tx*(my-cy) - ty*(mx-cy); // signed area
      const round = Math.min(0.5, Math.max(0.1, Math.hypot(tx,ty)/600));
      if(!e.smooth || typeof e.smooth!=='object') e.smooth = {};
      upd.push({ id:e.id, smooth: { enabled:true, type: (zx>0?'curvedCCW':'curvedCW'), roundness: round } });
    });
    if(upd.length) edges.update(upd);
  }
  document.getElementById('btnRotate').onclick = ()=>{
    const deg = parseFloat(document.getElementById('angle').value||'0') || 0;
    rotateSelection(deg);
  };

  // ======= Copy / Paste / Clone+Rotate =======
  let clip = null;
  function copySelection(){
    const selN = network.getSelectedNodes(); if(!selN.length){ clip=null; updateSelCount(); return; }
    const ns = nodes.get(selN);
    const cx = ns.reduce((s,n)=>s+n.x,0)/ns.length, cy = ns.reduce((s,n)=>s+n.y,0)/ns.length;
    const mapIdx = new Map(selN.map((id,i)=>[id,i]));
    const es = edges.get().filter(e=>mapIdx.has(e.from) && mapIdx.has(e.to));
    clip = {
      nodes: ns.map(n=>({ id:n.id, dx:n.x-cx, dy:n.y-cy, label:n.label, group:n.group, type:n.type, shape:n.shape, color:n.color, size:n.size })),
      edges: es.map(e=>({ from:e.from, to:e.to, smooth:e.smooth||false, width:e.width||1.5 }))
    };
  }
  function pasteClipboard(offsetX=40, offsetY=20){
    if(!clip) return;
    const base = nextId(); let cur=base; const idMap = new Map();
    clip.nodes.forEach(n=>{
      nodes.add({ id:cur, label:n.label, group:n.group, type:n.type, shape:n.shape, color:n.color, size:n.size,
                  x:n.dx+offsetX, y:n.dy+offsetY, fixed:false });
      idMap.set(n.id, cur); cur++;
    });
    clip.edges.forEach(e=>{
      const f = idMap.get(e.from), t = idMap.get(e.to);
      if(f!=null && t!=null) edges.add({ from:f, to:t, smooth:e.smooth||false, width:e.width||1.5 });
    });
    pushHistory();
    network.unselectAll();
    const newIds = [...idMap.values()];
    network.setSelection({ nodes:newIds });
    updateSelCount();
    return newIds;
  }
  function cloneRotate(){
    copySelection(); if(!clip) return;
    const deg = parseFloat(document.getElementById('angle').value||'0') || 0;
    const newIds = pasteClipboard();
    if(newIds && newIds.length){ rotateSelection(deg); }
  }
  document.getElementById('btnCopy').onclick = ()=>copySelection();
  document.getElementById('btnPaste').onclick = ()=>pasteClipboard();
  document.getElementById('btnCloneRotate').onclick = ()=>cloneRotate();

  // shortcuts
  document.addEventListener('keydown', (e)=>{
    const mod = e.metaKey || e.ctrlKey;
    const tag = e.target.tagName;
    const typing = tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable;
    if(typing) return;
    const k = e.key.toLowerCase();
    if(mod && k==='z'){ e.preventDefault(); if(e.shiftKey) redo(); else undo(); }
    if(mod && k==='c'){ e.preventDefault(); copySelection(); }
    if(mod && k==='v'){ e.preventDefault(); pasteClipboard(); }
  });
  document.getElementById('btnUndo').onclick = ()=>undo();
  document.getElementById('btnRedo').onclick = ()=>redo();

  // ======= Per-edge Style =======
  function applyEdgeStyle(style, onlySel){
    const ids = onlySel ? network.getSelectedEdges() : edges.getIds();
    const updates = ids.map(id=>{
      const e = edges.get(id);
      if(style==='straight'){ e.smooth = false; }
      else if(style==='dynamic'){ e.smooth = { enabled:true, type:'dynamic' }; }
      else if(style==='curvedCW'){ e.smooth = { enabled:true, type:'curvedCW', roundness:0.2 }; }
      else if(style==='curvedCCW'){ e.smooth = { enabled:true, type:'curvedCCW', roundness:0.2 }; }
      return e;
    });
    edges.update(updates);
    pushHistory();
  }
  document.getElementById('btnApplyEdgeStyle').onclick = ()=>{
    applyEdgeStyle(document.getElementById('edgeStyle').value, document.getElementById('edgeApplySel').checked);
  };

  // ======= Inspector =======
  const nodeLabel = document.getElementById('nodeLabel');
  const nodeX = document.getElementById('nodeX');
  const nodeY = document.getElementById('nodeY');
  const nodeGroup = document.getElementById('nodeGroup');
  const nodeType = document.getElementById('nodeType');
  const nodeShape = document.getElementById('nodeShape');
  const nodeColor = document.getElementById('nodeColor');
  const nodeSize = document.getElementById('nodeSize');

  function fillInspectorFromSelection(){
    const sel = network.getSelectedNodes();
    updateSelCount();
    if(sel.length !== 1){ nodeLabel.value=''; nodeX.value=''; nodeY.value=''; return; }
    const n = nodes.get(sel[0]);
    nodeLabel.value = n.label||'';
    nodeX.value = Math.round(n.x||0);
    nodeY.value = Math.round(n.y||0);
    nodeGroup.value = n.group||'Hub';
    nodeType.value = n.type||'basic';
    nodeShape.value = n.shape||'dot';
    const c = (typeof n.color==='string') ? n.color : (n.color?.border || '#7dd3fc');
    nodeColor.value = toHexColor(c);
    nodeSize.value = n.size||14;
  }
  function toHexColor(c){ // accepts named colors/#rgb/#rrggbb
    const d = document.createElement('div'); d.style.color=c; document.body.appendChild(d);
    const rgb = getComputedStyle(d).color; document.body.removeChild(d);
    const m = rgb.match(/(\d+),\s*(\d+),\s*(\d+)/);
    if(!m) return '#7dd3fc';
    return '#' + [m[1],m[2],m[3]].map(v=> ('0'+parseInt(v).toString(16)).slice(-2)).join('');
  }
  document.getElementById('btnApplyToSel').onclick = ()=>{
    const sel = network.getSelectedNodes(); if(!sel.length) return;
    const upd = sel.map(id=>({
      id,
      label: nodeLabel.value || undefined,
      x: Number(nodeX.value), y: Number(nodeY.value),
      group: nodeGroup.value, type: nodeType.value, shape: nodeShape.value,
      color: nodeColor.value, size: Number(nodeSize.value)||14
    }));
    nodes.update(upd);
    pushHistory();
  };

  // ======= Node style presets =======
  const PRESET_KEY='astral_node_presets_v1';
  function loadPresets(){ return JSON.parse(localStorage.getItem(PRESET_KEY) || '{}'); }
  function savePresets(p){ localStorage.setItem(PRESET_KEY, JSON.stringify(p)); }
  function refreshPresetList(){
    const list = document.getElementById('presetList'); list.innerHTML = '';
    const p = loadPresets();
    Object.keys(p).forEach(n=>{ const opt=document.createElement('option'); opt.value=n; opt.textContent=n; list.appendChild(opt); });
  }
  refreshPresetList();
  document.getElementById('btnSavePreset').onclick = ()=>{
    const name = (document.getElementById('presetName').value||'').trim(); if(!name) return;
    const preset = {
      group: nodeGroup.value, type: nodeType.value, shape: nodeShape.value,
      color: nodeColor.value, size: Number(nodeSize.value)||14
    };
    const p = loadPresets(); p[name]=preset; savePresets(p); refreshPresetList();
  };
  document.getElementById('btnApplyPreset').onclick = ()=>{
    const name = document.getElementById('presetList').value; if(!name) return;
    const p = loadPresets(); if(!p[name]) return;
    nodeGroup.value = p[name].group; nodeType.value = p[name].type; nodeShape.value = p[name].shape;
    nodeColor.value = p[name].color; nodeSize.value = p[name].size;
    document.getElementById('btnApplyToSel').click();
  };
  document.getElementById('btnUseForAdd').onclick = ()=>{
    const name = document.getElementById('presetList').value; if(!name) return;
    const p = loadPresets(); if(!p[name]) return; currentPreset = p[name];
    localStorage.setItem('astral_preset_current', JSON.stringify(currentPreset));
  };

  // ======= Effect presets (labels) =======
  const EFFECT_KEY='astral_effect_presets_v1';
  function loadEffects(){ try { return JSON.parse(localStorage.getItem(EFFECT_KEY)||'{}'); } catch(e){ return {}; } }
  function saveEffects(obj){ localStorage.setItem(EFFECT_KEY, JSON.stringify(obj)); }
  function refreshEffectList(){
    const list = document.getElementById('selEffs'); list.innerHTML='';
    const effs = loadEffects();
    Object.keys(effs).forEach(n=>{ const opt=document.createElement('option'); opt.value=n; opt.textContent=n; list.appendChild(opt); });
  }
  refreshEffectList();
  document.getElementById('btnSaveEff').onclick = ()=>{
    const name=(document.getElementById('effName').value||'').trim();
    const text=(document.getElementById('effText').value||'').trim();
    if(!name || !text) return;
    const effs=loadEffects(); effs[name]=text; saveEffects(effs); refreshEffectList();
    document.getElementById('effName').value=''; document.getElementById('effText').value='';
  };
  document.getElementById('btnApplyEff').onclick = ()=>{
    const name = document.getElementById('selEffs').value; if(!name) return;
    const effs = loadEffects(); const effect = effs[name]; if(!effect) return;
    const sel = network.getSelectedNodes(); if(!sel.length) return;
    nodes.update(sel.map(id=>({ id, label: effect })));
    pushHistory();
  };
  document.getElementById('btnUseEff').onclick = ()=>{
    const name = document.getElementById('selEffs').value; if(!name) return;
    const effs = loadEffects(); const effect = effs[name]; if(!effect) return;
    currentEffect = effect; localStorage.setItem('astral_effect_current', currentEffect);
  };

  // ======= Structure presets =======
  const STRUCT_KEY='astral_struct_presets_v1';
  function loadStructs(){ return JSON.parse(localStorage.getItem(STRUCT_KEY)||'{}'); }
  function saveStructs(obj){ localStorage.setItem(STRUCT_KEY, JSON.stringify(obj)); }
  function refreshStructList(){
    const list=document.getElementById('structList'); list.innerHTML='';
    const S=loadStructs(); Object.keys(S).forEach(n=>{ const opt=document.createElement('option'); opt.value=n; opt.textContent=n; list.appendChild(opt); });
  }
  refreshStructList();

  document.getElementById('btnSaveStruct').onclick = ()=>{
    const name = (document.getElementById('structName').value||'').trim(); if(!name) return;
    const sel = network.getSelectedNodes(); if(!sel.length) return;
    const ns = nodes.get(sel);
    const cx = ns.reduce((s,n)=>s+n.x,0)/ns.length, cy = ns.reduce((s,n)=>s+n.y,0)/ns.length;
    const selSet = new Set(sel);
    const es = edges.get().filter(e=>selSet.has(e.from) && selSet.has(e.to));
    const pack = {
      nodes: ns.map(n=>({ type:n.type, group:n.group, shape:n.shape, color:n.color, size:n.size, dx:n.x-cx, dy:n.y-cy })),
      edges: es.map(e=>({ ai: ns.findIndex(n=>n.id===e.from), bi: ns.findIndex(n=>n.id===e.to), smooth:e.smooth||false, width:e.width||1.5 }))
    };
    const S=loadStructs(); S[name]=pack; saveStructs(S); refreshStructList();
  };
  document.getElementById('btnPlaceStruct').onclick = ()=>{
    const name=document.getElementById('structList').value; const S=loadStructs(); const pack=S[name]; if(!pack) return;
    let cur = nextId(); const ids=[];
    pack.nodes.forEach(n=>{
      nodes.add({ id:cur, label:n.type==='notable'?'Notable':'B', group:n.group, type:n.type, shape:n.shape, color:n.color, size:n.size, x:n.dx, y:n.dy, fixed:false });
      ids.push(cur); cur++;
    });
    pack.edges.forEach(e=>{
      const from=ids[e.ai], to=ids[e.bi];
      if(from!=null && to!=null) edges.add({ from, to, smooth:e.smooth||false, width:e.width||1.5 });
    });
    pushHistory(); network.setSelection({nodes:ids}); updateSelCount();
  };
  document.getElementById('btnDeleteStruct').onclick = ()=>{
    const name=document.getElementById('structList').value; if(!name) return;
    const S=loadStructs(); if(!S[name]) return; delete S[name]; saveStructs(S); refreshStructList();
  };

  // ======= Polar snap =======
  function polarSnapSelection(){
    const sel=network.getSelectedNodes(); if(!sel.length) return;
    const rStep=parseFloat(document.getElementById('polarR').value||'100');
    const thStep=parseFloat(document.getElementById('polarTheta').value||'6');
    const upd=sel.map(id=>{
      const n=nodes.get(id);
      const r=Math.hypot(n.x, n.y);
      let th=Math.atan2(n.y, n.x)*180/Math.PI;
      if(th<0) th+=360;
      const r2=Math.round(r/rStep)*rStep;
      const th2=Math.round(th/thStep)*thStep * Math.PI/180;
      return { id, x: r2*Math.cos(th2), y: r2*Math.sin(th2) };
    });
    nodes.update(upd); pushHistory();
  }
  document.getElementById('btnPolar').onclick = ()=>{
    if(document.getElementById('polarToggle').checked) polarSnapSelection();
  };

  // ======= Edge style UI =======
  document.getElementById('btnFit').onclick = ()=> network.fit({animation:{duration:300}});

  // ======= Export / Import (positions-safe) =======
  function exportJSON(){
    const out = {
      nodes: nodes.get().map(n=>({
        id: Number(n.id),
        label: n.label,
        group: n.group,
        type: n.type,
        x: Number(n.x),
        y: Number(n.y),
        fixed: !!(n.fixed === true || (n.fixed && (n.fixed.x || n.fixed.y))),
        shape: n.shape,
        color: (typeof n.color === 'string' ? n.color : (n.color && n.color.border)) || '#7dd3fc',
        size: Number(n.size) || 14
      })),
      edges: edges.get().map(e=>({
        id: e.id,
        from: Number(e.from),
        to: Number(e.to),
        width: Number(e.width) || 1.5,
        smooth: (e.smooth === undefined ? false : e.smooth)
      })),
      settings: { grid: grid.on, gridSize: grid.size }
    };
    const blob = new Blob([JSON.stringify(out,null,2)], { type:'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'astral_tree.json'; a.click();
    URL.revokeObjectURL(url);
  }

  function importJSON(obj){
    nodes.clear(); edges.clear();

    // Nodes ‚Äî coerce types, preserve x/y, filter invalid coords
    const ns = (obj.nodes || []).map(n => ({
      id: Number(n.id),
      label: n.label ?? (n.type === 'notable' ? 'Notable' : 'B'),
      group: n.group ?? 'Hub',
      type: n.type ?? 'basic',
      x: Number(n.x),
      y: Number(n.y),
      fixed: (n.fixed ?? false) ? true : false,
      shape: n.shape ?? 'dot',
      color: (typeof n.color === 'string') ? { border: n.color } :
             (n.color && n.color.border) ? { border: n.color.border } :
             { border: '#7dd3fc' },
      size: Number(n.size) || 14
    })).filter(n => Number.isFinite(n.x) && Number.isFinite(n.y));

    nodes.add(ns);

    // Edges ‚Äî drop any that reference missing nodes
    const validIds = new Set(nodes.getIds().map(Number));
    let dropped = 0;
    const es = (obj.edges || []).filter(e=>{
      const ok = validIds.has(Number(e.from)) && validIds.has(Number(e.to));
      if(!ok) dropped++;
      return ok;
    }).map(e => ({
      id: e.id,
      from: Number(e.from),
      to: Number(e.to),
      width: Number(e.width) || 1.5,
      smooth: (e.smooth === undefined ? false : e.smooth)
    }));

    edges.add(es);

    // Settings
    if (obj.settings){
      grid.on = !!obj.settings.grid;
      grid.size = Number(obj.settings.gridSize) || grid.size;
      document.getElementById('gridToggle').checked = grid.on;
      document.getElementById('gridSize').value = grid.size;
      drawGrid();
    }

    // No re-layout, physics disabled. Fit view.
    network.fit({ animation:{ duration:300 } });
    pushHistory();

    if(dropped){
      alert(`Imported with ${dropped} edge(s) skipped because their endpoints were missing.`);
    }
  }

  document.getElementById('btnExport').onclick = exportJSON;
  document.getElementById('btnImport').onclick = ()=>{
    const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json,.json';
    inp.onchange = ()=>{
      const f = inp.files?.[0]; if(!f) return;
      const rd = new FileReader();
      rd.onload = ()=>{
        try{ const obj = JSON.parse(rd.result); importJSON(obj); }
        catch(e){ console.error(e); alert('Invalid JSON'); }
      };
      rd.readAsText(f);
    };
    inp.click();
  };

  // ======= Seed minimal =======
  nodes.add([
    {id:1,label:'B',group:'Hub',type:'basic',x:0,y:0,fixed:false},
    {id:2,label:'B',group:'Hub',type:'basic',x:120,y:60,fixed:false}
  ]);
  edges.add([{from:1,to:2}]);
  pushHistory();

  // initial UI
  updateSelCount();
  drawGrid();
}
</script>
</body>
</html>
