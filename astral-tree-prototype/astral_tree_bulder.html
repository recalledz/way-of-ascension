<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Astral Tree Editor — Rotation, Undo, Per-Edge Styles, Presets</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f172a; --ink:#e5e7eb; --muted:#94a3b8; --brand:#22d3ee; --accent:#7dd3fc;
    --grid: #23304a; --grid-strong:#2f3e63;
  }
  html,body{height:100%;}
  body{margin:0; color:var(--ink); font:14px/1.2 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
       display:grid; grid-template-rows:auto 1fr; background:var(--bg);}  
  header{position:relative; z-index:2; display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:10px;
         background:linear-gradient(180deg,var(--panel),transparent);}  
  #wrap{position:relative; height:100%; min-height:0;}
  #network{position:absolute; inset:0;}
  .group{display:flex; gap:8px; align-items:center; background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:10px;}
  label{color:var(--muted);}
  input,select,button{background:#0b1220; color:var(--ink); border:1px solid #2a385a; border-radius:8px; padding:6px 8px;}
  button{cursor:pointer}
  button.primary{background:linear-gradient(180deg,#1d283a,#13203a); border-color:#2a4b73}
  button.danger{background:linear-gradient(180deg,#3a1d1d,#2a1313); border-color:#733a3a}
  #sidebar{position:absolute; top:12px; right:12px; width:320px; max-width:46vw; z-index:3; background:rgba(15,23,42,0.9); border:1px solid #26314d; border-radius:12px; backdrop-filter: blur(6px);}
  #sidebar header{background:none; padding:10px; gap:6px}
  #sidebar section{padding:10px; border-top:1px solid #1f2a44}
  .row{display:flex; gap:8px; align-items:center; margin-bottom:8px}
  .row > *{flex:1}
  .row .shrink{flex:0 0 auto}
  small{color:var(--muted)}
  .tag{padding:2px 6px; border:1px solid #2a385a; border-radius:999px; color:#a5b4fc}
  .divider{height:1px; background:#1f2a44; margin:8px 0}
  .hint{color:#a5b4fc}
</style>
</head>
<body>
  <header>
    <div class="group">
      <button id="btnAddNode">Add Node (preset)</button>
      <button id="btnAddEdge">Edge Mode</button>
      <button id="btnRotate" title="Rotate selected by angle">Rotate</button>
      <label>°<input id="angle" type="number" value="20" style="width:70px"></label>
      <button id="btnUndo">Undo ⌘/Ctrl+Z</button>
    </div>
    <div class="group">
      <label class="shrink">Edge Style</label>
      <select id="edgeStyle">
        <option value="straight">Straight</option>
        <option value="curvedCW">Curved CW</option>
        <option value="curvedCCW">Curved CCW</option>
        <option value="dynamic">Dynamic</option>
      </select>
      <label class="shrink"><input type="checkbox" id="edgeApplySel" checked> apply to selection</label>
      <button id="btnApplyEdgeStyle">Apply</button>
    </div>
    <div class="group">
      <button id="btnImport">Import JSON</button>
      <button id="btnExport">Export JSON</button>
      <button id="btnFit">Fit</button>
      <label class="shrink"><input type="checkbox" id="gridToggle"> Grid</label>
      <label class="shrink"><input type="checkbox" id="snapToggle" checked> Snap</label>
    </div>
    <div class="group"><span id="status" class="hint">Loading vis-network…</span></div>
  </header>
  <div id="wrap">
    <div id="network"></div>
    <aside id="sidebar">
      <header>
        <strong>Inspector</strong>
        <small id="selCount">0 selected</small>
      </header>
      <section>
        <div class="row">
          <label class="shrink">Group</label>
          <select id="nodeGroup">
            <option>Hub</option><option>Wood</option><option>Fire</option><option>Earth</option><option>Metal</option><option>Water</option>
          </select>
        </div>
        <div class="row">
          <label class="shrink">Type</label>
          <select id="nodeType"><option>basic</option><option>notable</option></select>
          <label class="shrink">Shape</label>
          <select id="nodeShape"><option value="dot">dot</option><option value="diamond">diamond</option><option value="triangle">triangle</option></select>
        </div>
        <div class="row">
          <label class="shrink">Color</label>
          <input id="nodeColor" type="color" value="#7dd3fc" />
          <label class="shrink">Size</label>
          <input id="nodeSize" type="number" value="14" min="6" max="50" />
        </div>
        <div class="row">
          <button id="btnApplyToSel" class="primary">Apply to selection</button>
        </div>
      </section>
      <section>
        <header style="padding:0 0 8px 0"><strong>Presets</strong></header>
        <div class="row">
          <input id="presetName" placeholder="Preset name" />
          <button id="btnSavePreset">Save</button>
        </div>
        <div class="row">
          <select id="presetList" style="width:100%"></select>
        </div>
        <div class="row">
          <button id="btnApplyPreset" class="primary">Apply to selection</button>
          <button id="btnUseForAdd">Use for Add</button>
        </div>
      </section>
    </aside>
  </div>

<script>
// Dynamic loader with fallbacks
(function(){
  const status = document.getElementById('status');
  const tries = [
    'https://cdn.jsdelivr.net/npm/vis-network@9.1.6/dist/vis-network.min.js',
    'https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.6/vis-network.min.js'
  ];
  let i=0;
  function loadNext(){
    if(i>=tries.length){ status.textContent = 'Unable to load vis-network (CDN blocked)'; return; }
    const s=document.createElement('script'); s.src=tries[i++]; s.onload=init; s.onerror=loadNext; document.head.appendChild(s);
  }
  loadNext();
})();

function init(){
  const status = document.getElementById('status');
  status.textContent = 'Ready ✓ vis-network';

  // Graph data
  const nodes = new vis.DataSet([]);
  const edges = new vis.DataSet([]);

  // Undo stack
  const history = [];
  function pushHistory(label){
    const snapshot = JSON.stringify({nodes:nodes.get(), edges:edges.get()});
    history.push(snapshot);
    if(history.length>100) history.shift();
  }
  function undo(){
    if(history.length<2) return; // keep current + previous
    history.pop();
    const prev = JSON.parse(history[history.length-1]);
    nodes.clear(); edges.clear();
    nodes.add(prev.nodes); edges.add(prev.edges);
  }

  // Grid + snap
  const grid = { on:false, size:30 };
  const gridToggle = document.getElementById('gridToggle');
  const snapToggle = document.getElementById('snapToggle');
  gridToggle.addEventListener('change', ()=>{ grid.on = gridToggle.checked; drawGrid(); });
  snapToggle.addEventListener('change', ()=>{ /* flag only */ });

  const container = document.getElementById('network');
  const data = { nodes, edges };
  const options = {
    autoResize: true,
    physics: false,
    interaction:{ hover:true, multiselect:true, navigationButtons:false, keyboard:true },
    nodes:{ shape:'dot', size:14, borderWidth:2, color:{background:'#111827', border:'#334155', highlight:{background:'#0b1220', border:'#ecfeff'}}, font:{color:'#e5e7eb'} },
    edges:{ color:{color:'#475569', highlight:'#7dd3fc'}, width:1.5, smooth:false, selectionWidth:2 },
    layout:{ improvedLayout:false }
  };
  const network = new vis.Network(container, data, options);

  // Draw grid background
  let gridCanvas, gridCtx; 
  function drawGrid(){
    if(!gridCanvas){
      gridCanvas = document.createElement('canvas');
      gridCanvas.style.position='absolute'; gridCanvas.style.left=0; gridCanvas.style.top=0; gridCanvas.style.right=0; gridCanvas.style.bottom=0; gridCanvas.style.zIndex=0;
      gridCtx = gridCanvas.getContext('2d');
      container.appendChild(gridCanvas);
    }
    const rect = container.getBoundingClientRect();
    gridCanvas.width = rect.width; gridCanvas.height = rect.height;
    gridCanvas.style.display = grid.on ? 'block':'none';
    if(!grid.on) return;
    gridCtx.clearRect(0,0,rect.width,rect.height);
    gridCtx.strokeStyle = '#23304a'; gridCtx.lineWidth=1;
    const step = grid.size;
    for(let x=0; x<rect.width; x+=step){ gridCtx.beginPath(); gridCtx.moveTo(x,0); gridCtx.lineTo(x,rect.height); gridCtx.stroke(); }
    for(let y=0; y<rect.height; y+=step){ gridCtx.beginPath(); gridCtx.moveTo(0,y); gridCtx.lineTo(rect.width,y); gridCtx.stroke(); }
  }
  window.addEventListener('resize', drawGrid);
  drawGrid();

  // Helpers
  function nextId(){ const all = nodes.getIds(); return all.length? Math.max(...all)+1 : 1; }
  function getSel(){ return { n: network.getSelectedNodes(), e: network.getSelectedEdges() }; }
  function updateSelCount(){ document.getElementById('selCount').textContent = `${network.getSelectedNodes().length} nodes, ${network.getSelectedEdges().length} edges selected`; }

  // Snap on drag end
  network.on('dragEnd', (params)=>{
    if(!snapToggle.checked) return;
    const ids = params.nodes; if(!ids || !ids.length) return;
    const size = grid.size;
    const updates = ids.map(id=>{
      const n = nodes.get(id);
      const x = Math.round(n.x/size)*size;
      const y = Math.round(n.y/size)*size;
      return {id, x, y, fixed:true};
    });
    nodes.update(updates);
  });
  network.on('selectNode', updateSelCount);
  network.on('deselectNode', updateSelCount);
  network.on('selectEdge', updateSelCount);
  network.on('deselectEdge', updateSelCount);

  // Add Node (from preset)
  const defaultPreset = { group:'Hub', type:'basic', shape:'dot', color:'#7dd3fc', size:14 };
  let currentPreset = JSON.parse(localStorage.getItem('astral_preset_current')||JSON.stringify(defaultPreset));

  document.getElementById('btnAddNode').onclick = ()=>{
    const id = nextId();
    const pos = network.getViewPosition();
    const scale = network.getScale();
    const center = network.canvas.body.container.getBoundingClientRect();
    const x = 0, y = 0; // default near origin; user can drag
    nodes.add({ id, label: currentPreset.type==='notable'?'Notable':'B', group: currentPreset.group, type: currentPreset.type, shape: currentPreset.shape, color:{border: currentPreset.color}, size: currentPreset.size, x, y, fixed:false });
    pushHistory('add node');
  };

  // Edge mode
  let edgeMode=false, edgeFrom=null;
  document.getElementById('btnAddEdge').onclick = ()=>{ edgeMode = !edgeMode; edgeFrom=null; document.getElementById('btnAddEdge').textContent = edgeMode? 'Edge Mode (ON)':'Edge Mode'; };
  network.on('click', (p)=>{
    if(!edgeMode) return;
    const nodeId = p.nodes[0];
    if(!nodeId) return;
    if(edgeFrom==null){ edgeFrom=nodeId; }
    else{ edges.add({from:edgeFrom, to:nodeId}); edgeFrom=null; pushHistory('add edge'); }
  });

  // Rotate selection
  function rotateSelection(deg){
    const ids = network.getSelectedNodes(); if(!ids.length) return;
    const pts = ids.map(id=>nodes.get(id));
    const cx = pts.reduce((s,n)=>s+n.x,0)/pts.length;
    const cy = pts.reduce((s,n)=>s+n.y,0)/pts.length;
    const a = deg*Math.PI/180;
    const cos=Math.cos(a), sin=Math.sin(a);
    const upd = pts.map(n=>({ id:n.id, x: cx + (n.x-cx)*cos - (n.y-cy)*sin, y: cy + (n.x-cx)*sin + (n.y-cy)*cos }));
    nodes.update(upd);
  }
  document.getElementById('btnRotate').onclick = ()=>{ const deg = parseFloat(document.getElementById('angle').value||'0'); rotateSelection(deg); pushHistory('rotate'); };

  // Undo
  document.getElementById('btnUndo').onclick = ()=>undo();
  document.addEventListener('keydown', (e)=>{ if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); } });

  // Apply edge style (per-edge)
  function applyEdgeStyle(style, onlySel){
    const ids = onlySel? network.getSelectedEdges() : edges.getIds();
    if(!ids.length) return;
    const updates = ids.map(id=>{
      const e={id, smooth:false};
      if(style==='straight'){ e.smooth=false; }
      else if(style==='dynamic'){ e.smooth={enabled:true, type:'dynamic'}; }
      else if(style==='curvedCW'){ e.smooth={enabled:true, type:'curvedCW', roundness:0.2}; }
      else if(style==='curvedCCW'){ e.smooth={enabled:true, type:'curvedCCW', roundness:0.2}; }
      return e;
    });
    edges.update(updates);
  }
  document.getElementById('btnApplyEdgeStyle').onclick = ()=>{
    applyEdgeStyle(document.getElementById('edgeStyle').value, document.getElementById('edgeApplySel').checked);
    pushHistory('edge style');
  };

  // Inspector apply to selection (edit existing nodes)
  function applyToSelection(){
    const sel = network.getSelectedNodes(); if(!sel.length) return;
    const group = document.getElementById('nodeGroup').value;
    const type = document.getElementById('nodeType').value;
    const shape = document.getElementById('nodeShape').value;
    const color = document.getElementById('nodeColor').value;
    const size  = parseInt(document.getElementById('nodeSize').value,10)||14;
    const upd = sel.map(id=>({ id, group, type, shape, color:{ border: color }, size }));
    nodes.update(upd);
    pushHistory('edit nodes');
  }
  document.getElementById('btnApplyToSel').onclick = applyToSelection;

  // Presets (localStorage)
  const PRESET_KEY='astral_node_presets_v1';
  function loadPresets(){ return JSON.parse(localStorage.getItem(PRESET_KEY) || '{}'); }
  function savePresets(p){ localStorage.setItem(PRESET_KEY, JSON.stringify(p)); }
  function refreshPresetList(){
    const list=document.getElementById('presetList'); list.innerHTML='';
    const p=loadPresets(); const names=Object.keys(p);
    if(!names.length){ const opt=document.createElement('option'); opt.textContent='(no presets yet)'; list.appendChild(opt); return; }
    names.forEach(n=>{ const opt=document.createElement('option'); opt.value=n; opt.textContent=n; list.appendChild(opt); });
  }
  refreshPresetList();
  document.getElementById('btnSavePreset').onclick = ()=>{
    const name = document.getElementById('presetName').value.trim(); if(!name) return;
    const preset = {
      group: document.getElementById('nodeGroup').value,
      type: document.getElementById('nodeType').value,
      shape: document.getElementById('nodeShape').value,
      color: document.getElementById('nodeColor').value,
      size: parseInt(document.getElementById('nodeSize').value,10)||14
    };
    const p = loadPresets(); p[name]=preset; savePresets(p); refreshPresetList();
  };
  document.getElementById('btnApplyPreset').onclick = ()=>{
    const name=document.getElementById('presetList').value; const p=loadPresets(); if(!p[name]) return;
    // push preset values into inspector then apply
    document.getElementById('nodeGroup').value=p[name].group;
    document.getElementById('nodeType').value=p[name].type;
    document.getElementById('nodeShape').value=p[name].shape;
    document.getElementById('nodeColor').value=p[name].color;
    document.getElementById('nodeSize').value=p[name].size;
    applyToSelection();
  };
  document.getElementById('btnUseForAdd').onclick = ()=>{
    const name=document.getElementById('presetList').value; const p=loadPresets(); if(!p[name]) return;
    currentPreset = p[name]; localStorage.setItem('astral_preset_current', JSON.stringify(currentPreset));
  };

  // Export/Import JSON
  function exportJSON(){
    const out = { nodes: nodes.get().map(n=>({id:n.id,label:n.label,group:n.group,type:n.type,x:n.x,y:n.y,fixed:!!n.fixed})), edges: edges.get().map(e=>({id:e.id,from:e.from,to:e.to,width:e.width||1.5, smooth:e.smooth||false})), settings:{ grid:grid.on, gridSize:grid.size } };
    const blob = new Blob([JSON.stringify(out)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='astral_tree.json'; a.click(); URL.revokeObjectURL(url);
  }
  function importJSON(obj){
    nodes.clear(); edges.clear();
    const ns = (obj.nodes||[]).map(n=>({id:n.id,label:n.label|| (n.type==='notable'?'Notable':'B'),group:n.group||'Hub',type:n.type||'basic',x:n.x||0,y:n.y||0,fixed:!!n.fixed}));
    const es = (obj.edges||[]).map(e=>({id:e.id,from:e.from,to:e.to,width:e.width||1.5,smooth: e.smooth===undefined? false : e.smooth }));
    nodes.add(ns); edges.add(es);
    grid.on = !!(obj.settings && obj.settings.grid); grid.size = (obj.settings && obj.settings.gridSize)||30; document.getElementById('gridToggle').checked = grid.on; drawGrid();
    pushHistory('import');
  }
  document.getElementById('btnExport').onclick = exportJSON;
  document.getElementById('btnImport').onclick = ()=>{
    const inp=document.createElement('input'); inp.type='file'; inp.accept='.json,application/json';
    inp.onchange = ()=>{
      const f=inp.files[0]; if(!f) return; const rd=new FileReader(); rd.onload = ()=>{ try{ const obj=JSON.parse(rd.result); importJSON(obj); }catch(e){ alert('Invalid JSON'); } }; rd.readAsText(f);
    };
    inp.click();
  };

  // Fit button
  document.getElementById('btnFit').onclick = ()=> network.fit({animation:{duration:300}});

  // Seed with a tiny starter so the canvas is interactive
  nodes.add([{id:1,label:'B',group:'Hub',type:'basic',x:0,y:0,fixed:false},{id:2,label:'B',group:'Hub',type:'basic',x:120,y:60,fixed:false}]);
  edges.add([{from:1,to:2}]);
  pushHistory('seed');
}
</script>
</body>
</html>
